** YDKJS -> Scopes & Closures

IIFE (immediately invoked function expression)


//
// Protect 'undefined' from overwriting.
//

undefined = true; // setting a land-mine for other code! avoid!

(function IIFE(undefined) {
  var a;
  if (a === undefined) {
    console.log("Undefined is safe here!");
  }
})();


//
// Pattern used in the UMD (Universal Module Definition).
//

var a = 2;

(function IIFE(def) {
  def(window);
})(function def(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
});


//
// Hoisting.
//

function f() {
	a = 2;
	var a;
	console.log( a ); // Outputs '2'.
	console.log( window.a ); // Outputs 'undefined'.
}

function f() {
	console.log( a ); // Outputs 'undefined'.
	var a = 2;
}

function f() {
	console.log( a ); // Reference error.
}

foo(); // TypeError! Function expression are not hoisted.
var foo = function bar() {
 // ...
};


function declarations are hoisted before normal variables


//
// Closures.
//

function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }
  return bar;
}

var baz = foo();

baz(); // 2 -- Whoa, closure was just observed, man.


//
// Another kind of closure. Strange, as for me.
//

function foo() {
  var a = 2;

  function baz() {
    console.log(a); // 2
  }

  bar(baz);
}

function bar(fn) {
  fn(); // look ma, I saw closure!
}


//
// One more form.
//

var fn;

function foo() {
  var a = 2;

  function baz() {
    console.log(a);
  }

  fn = baz; // assign baz to global variable
}

function bar() {
  fn(); // look ma, I saw closure!
}

foo();

bar(); // 2


••••
••••

//<script>

//
// >>>> Default binding.
//

function foo() {
    console.log(this.a);
}

var a = 2;

foo(); // 2



//
// >>>> Strict mode.
//

function foo() {
    "use strict";
    console.log(this.a);
}

var a = 2;

foo(); // TypeError: `this` is `undefined`



//
// >>>> Implicit binding.
//

function foo() {
    console.log(this.a);
}

var obj = {
    a: 2,
    foo: foo
};

obj.foo(); // 2



//
// >>>> `a: 2` here is not accessible
//

function foo() {
  console.log(this.a);
}

var obj2 = {
  a: 42,
  foo: foo
};

var obj1 = {
  a: 2,
  obj2: obj2
};

obj1.obj2.foo(); // 42



//
// >>>> * Implicitly lost
//

function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo
};

var bar = obj.foo; // function reference/alias!

var a = "oops, global"; // `a` also property on global object

bar(); // "oops, global"



//
// >>>> *
//

function foo() {
  console.log(this.a);
}

function doFoo(fn) {
  // `fn` is just another reference to `foo`

  fn(); // <-- call-site!
}

var obj = {
  a: 2,
  foo: foo
};

var a = "oops, global"; // `a` also property on global object

doFoo(obj.foo); // "oops, global"



//
// >>>> *
//

function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo
};

var a = "oops, global"; // `a` also property on global object

setTimeout(obj.foo, 100); // "oops, global"



//
// >>>> Explicit Binding
//

function foo() {
  console.log(this.a);
}

var obj = {
  a: 2
};

foo.call(obj); // 2



//
// >>>> * Hard binding
//

function foo() {
  console.log(this.a);
}

var obj = {
  a: 2
};

var bar = function() {
  foo.call(obj);
};

bar(); // 2
setTimeout(bar, 100); // 2

// hard-bound `bar` can no longer have its `this` overridden
bar.call(window); // 2



//
// >>>> *
//

function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

var obj = {
  a: 2
};

var bar = function() {
  return foo.apply(obj, arguments);
};

var b = bar(3); // 2 3
console.log(b); // 5




···· //
···· //
···· //
···· 
···· if (!Function.prototype.bind) {
····  Function.prototype.bind = function(oThis) {
····   if (typeof this !== "function") {
····    // closest thing possible to the ECMAScript 5
····    // internal IsCallable function
····    throw new TypeError(
····     "Function.prototype.bind - what is trying " +
····     "to be bound is not callable"
····    );
····   }
···· 
····   var aArgs = Array.prototype.slice.call(arguments, 1),
····    fToBind = this,
····    fNOP = function() {},
····    fBound = function() {
····     return fToBind.apply(
····      (
····       this instanceof fNOP &&
····       oThis ? this : oThis
····      ),
····      aArgs.concat(
····       Array.prototype.slice.call(arguments)
····      );
····    };
···· 
····   fNOP.prototype = this.prototype;
····   fBound.prototype = new fNOP();
···· 
····   return fBound;
····  };
···· }

//</script>